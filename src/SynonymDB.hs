{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE OverloadedStrings #-}

-- | Synonym Database Loader
--
-- Loads the embedded synonym database from the compiled binary.
-- The database maps flow names to synonym group IDs for flow matching
-- across different nomenclatures (ILCD, ecoinvent, SimaPro).
--
-- The binary is embedded at compile time using file-embed, and decompressed
-- on first use.
module SynonymDB
    ( -- * Loading
      loadEmbeddedSynonymDB
      -- * Lookup
    , lookupSynonymGroup
    , getSynonyms
    , normalizeName
      -- * Re-exports
    , SynonymDB(..)
    , emptySynonymDB
    ) where

import Control.DeepSeq (force)
import Control.Exception (evaluate)
import qualified Codec.Compression.Zstd as Zstd
import qualified Data.Binary as Binary
import qualified Data.ByteString as BS
import qualified Data.ByteString.Lazy as BSL
import Data.FileEmbed (embedFile)
import qualified Data.Map.Strict as M
import Data.Text (Text)
import qualified Data.Text as T

import SynonymDB.Types (SynonymDB(..), emptySynonymDB)

-- | Embedded synonym database (compressed with Zstd)
--
-- This file is generated by running:
--   cabal run synonyms-compiler -- \
--       --input scripts/synonyms_db.json \
--       --output src/SynonymDB/synonyms.bin.zst
--
-- If the file doesn't exist at compile time, we embed an empty placeholder
-- and return an empty database at runtime.
synonymsCompressed :: BS.ByteString
synonymsCompressed = $(embedFile "src/SynonymDB/synonyms.bin.zst")

-- | Load the embedded synonym database
--
-- This function:
-- 1. Decompresses the embedded Zstd data
-- 2. Deserializes the Binary format into SynonymDB
-- 3. Forces full evaluation to prevent lazy thunk buildup
--
-- Should be called once at startup and stored in the Database record.
loadEmbeddedSynonymDB :: IO SynonymDB
loadEmbeddedSynonymDB = do
    -- Handle empty placeholder (when file not yet generated)
    if BS.null synonymsCompressed
        then return emptySynonymDB
        else do
            -- Decompress
            case Zstd.decompress synonymsCompressed of
                Zstd.Skip -> do
                    putStrLn "Warning: Synonym DB decompression skipped (empty data)"
                    return emptySynonymDB
                Zstd.Error err -> do
                    putStrLn $ "Warning: Synonym DB decompression failed: " ++ show err
                    return emptySynonymDB
                Zstd.Decompress decompressed -> do
                    -- Deserialize
                    let !db = Binary.decode (BSL.fromStrict decompressed)
                    -- Force full evaluation
                    !db' <- evaluate (force db)
                    let nameCount = M.size (synNameToId db')
                        groupCount = M.size (synIdToNames db')
                    putStrLn $ "Loaded synonym DB: " ++ show nameCount
                        ++ " names, " ++ show groupCount ++ " groups"
                    return db'

-- | Normalize a name for lookup in the synonym database
--
-- Normalization rules (must match build_synonyms_db.py):
-- - Lowercase
-- - Strip leading/trailing whitespace
-- - Collapse multiple spaces to single space
-- - Strip ", in ground" suffix (ecoinvent resource naming)
-- - Strip "/kg" suffix (SimaPro unit convention)
-- - Remove punctuation: commas, parentheses, quotes
normalizeName :: Text -> Text
normalizeName name =
    let -- Lowercase and strip
        t1 = T.strip $ T.toLower name
        -- Collapse whitespace
        t2 = T.unwords $ T.words t1
        -- Strip ", in ground" suffix
        t3 = stripSuffix ", in ground" $ stripSuffix " in ground" t2
        -- Strip "/kg" suffix
        t4 = stripSuffix "/kg" t3
        -- Remove punctuation
        t5 = T.filter (`notElem` (",()'\"" :: String)) t4
        -- Collapse whitespace again (from removed punctuation)
        t6 = T.unwords $ T.words t5
    in t6
  where
    stripSuffix :: Text -> Text -> Text
    stripSuffix suffix txt =
        if suffix `T.isSuffixOf` txt
            then T.dropEnd (T.length suffix) txt
            else txt

-- | Look up the synonym group ID for a flow name
--
-- Returns Nothing if the name is not found in the database.
-- Names are automatically normalized before lookup.
lookupSynonymGroup :: SynonymDB -> Text -> Maybe Int
lookupSynonymGroup db name =
    M.lookup (normalizeName name) (synNameToId db)

-- | Get all synonyms for a group ID
--
-- Returns Nothing if the group ID is not found.
getSynonyms :: SynonymDB -> Int -> Maybe [Text]
getSynonyms db gid = M.lookup gid (synIdToNames db)
