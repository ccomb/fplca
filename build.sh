#!/bin/bash

# =============================================================================
# fplca build script with PETSc/SLEPc
# =============================================================================
# This script builds fplca with PETSc/SLEPc integration.
# It can automatically download and build PETSc/SLEPc if not found.
# Works on Linux, macOS, and Windows (via MSYS2).
#
# Usage:
#   ./build.sh [options]
#
# Options:
#   --help              Show this help message
#   --clean             Clean build artifacts before building
#   --all               Force re-download and rebuild of PETSc/SLEPc
#   --test              Run tests after building
#   --desktop           Build desktop application (Tauri bundle)
#
# Environment variables:
#   PETSC_DIR           Path to PETSc installation
#   SLEPC_DIR           Path to SLEPc installation
#   PETSC_ARCH          PETSc architecture (default: auto-detected)
#
# Examples:
#   ./build.sh                      # Download deps if needed and build
#   ./build.sh --all                # Force re-download everything
#   ./build.sh --test               # Build and run tests
#
# Windows:
#   Run from MSYS2 UCRT64 terminal:
#   $ ./build.sh
#
# =============================================================================

set -e

# -----------------------------------------------------------------------------
# Configuration
# -----------------------------------------------------------------------------

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Source shared library functions
if [[ -f "$SCRIPT_DIR/lib.sh" ]]; then
    # shellcheck source=lib.sh
    source "$SCRIPT_DIR/lib.sh"
else
    echo "ERROR: lib.sh not found in $SCRIPT_DIR"
    exit 1
fi

# Source version definitions
if [[ -f "$SCRIPT_DIR/versions.env" ]]; then
    # shellcheck source=versions.env
    source "$SCRIPT_DIR/versions.env"
else
    log_error "versions.env not found in $SCRIPT_DIR"
    exit 1
fi

# Source PETSc configuration
if [[ -f "$SCRIPT_DIR/petsc.env" ]]; then
    # shellcheck source=petsc.env
    source "$SCRIPT_DIR/petsc.env"
else
    log_error "petsc.env not found in $SCRIPT_DIR"
    exit 1
fi

# Detect OS
OS=$(detect_os)

# Defaults
FORCE_REBUILD=false
RUN_TESTS=false
CLEAN_BUILD=false
BUILD_DESKTOP=false

# -----------------------------------------------------------------------------
# Parse arguments
# -----------------------------------------------------------------------------

while [[ $# -gt 0 ]]; do
    case $1 in
        --help|-h)
            show_help "$0"
            ;;
        --clean)
            CLEAN_BUILD=true
            shift
            ;;
        --all)
            FORCE_REBUILD=true
            shift
            ;;
        --test)
            RUN_TESTS=true
            shift
            ;;
        --desktop)
            BUILD_DESKTOP=true
            shift
            ;;
        *)
            log_error "Unknown option: $1"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
done

# Set default PETSC_ARCH based on OS
# Auto-detect existing PETSC_ARCH if not set
if [[ -z "$PETSC_ARCH" ]]; then
    PETSC_DIR_CHECK=${PETSC_DIR:-"$SCRIPT_DIR/petsc"}
    SLEPC_DIR_CHECK=${SLEPC_DIR:-"$SCRIPT_DIR/slepc"}
    PETSC_ARCH=$(detect_existing_petsc_arch "$PETSC_DIR_CHECK" "$SLEPC_DIR_CHECK")
fi

echo ""
log_info "Build configuration:"
log_info "  OS: $OS"
log_info "  PETSC_ARCH: $PETSC_ARCH"
echo ""

# Check MSYS2 environment on Windows
if [[ "$OS" == "windows" ]]; then
    if ! require_msys2_ucrt64; then
        exit 1
    fi
    # PETSc requires cygwin/msys python, not mingw python (which reports win32)
    PYTHON=/usr/bin/python3
else
    PYTHON=python3
fi

# -----------------------------------------------------------------------------
# Check dependencies
# -----------------------------------------------------------------------------

log_info "Checking dependencies..."

MISSING_DEPS=false

# Required build tools (platform-specific)
if [[ "$OS" == "windows" ]]; then
    # On Windows/MSYS2, check for MinGW tools
    for cmd in gcc make python3 curl tar git; do
        if ! check_command "$cmd"; then
            MISSING_DEPS=true
        fi
    done
else
    # Linux/macOS
    for cmd in gcc g++ make python3 curl tar; do
        if ! check_command "$cmd"; then
            MISSING_DEPS=true
        fi
    done
fi

# Fortran compiler (needed for PETSc)
if ! check_command "gfortran"; then
    log_warn "gfortran not found - PETSc build may fail"
    if [[ "$OS" == "windows" ]]; then
        log_warn "Install with: pacman -S mingw-w64-ucrt-x86_64-gcc-fortran"
    else
        log_warn "Install with: sudo apt install gfortran"
    fi
fi

# Haskell toolchain
for cmd in ghc cabal; do
    if ! check_command "$cmd"; then
        MISSING_DEPS=true
        log_warn "Install GHC and Cabal via ghcup: https://www.haskell.org/ghcup/"
    fi
done

# Node.js (needed for frontend build)
if ! check_command "npm"; then
    MISSING_DEPS=true
    log_warn "Install Node.js: https://nodejs.org/"
fi

# Rust (needed for desktop build)
check_command "rustc"

# Elm (installed via npm in web/ directory)
if command -v elm &>/dev/null; then
    log_success "elm found: $(command -v elm)"
else
    log_info "elm will be installed via npm in web/"
fi

if [[ "$MISSING_DEPS" == "true" ]]; then
    log_error "Missing required dependencies. Please install them and try again."
    echo ""
    if [[ "$OS" == "windows" ]]; then
        echo "On Windows (MSYS2 UCRT64):"
        echo "  pacman -S mingw-w64-ucrt-x86_64-gcc mingw-w64-ucrt-x86_64-gcc-fortran \\"
        echo "            mingw-w64-ucrt-x86_64-openblas make python git"
        echo ""
    elif [[ "$OS" == "macos" ]]; then
        echo "On macOS:"
        echo "  brew install gcc python3 curl node"
        echo ""
    else
        echo "On Debian/Ubuntu:"
        echo "  sudo apt install build-essential python3 curl gfortran liblapack-dev libblas-dev nodejs npm"
        echo ""
        echo "On Fedora:"
        echo "  sudo dnf install gcc gcc-c++ gcc-gfortran make python3 curl lapack-devel blas-devel nodejs npm"
        echo ""
        echo "On Arch Linux:"
        echo "  sudo pacman -S base-devel python curl gcc-fortran lapack blas nodejs npm"
        echo ""
    fi
    echo "For Haskell toolchain:"
    echo "  curl --proto '=https' --tlsv1.2 -sSf https://get-ghcup.haskell.org | sh"
    exit 1
fi

# -----------------------------------------------------------------------------
# Check tool versions
# -----------------------------------------------------------------------------

log_info "Checking tool versions..."

# Check GHC version
GHC_ACTUAL=$(ghc --numeric-version)
check_version "GHC" "$GHC_ACTUAL" "$GHC_VERSION"

# Check Node version
if command -v node &> /dev/null; then
    NODE_ACTUAL=$(node --version | sed 's/^v//')
    check_version "Node.js" "$NODE_ACTUAL" "$NODE_VERSION"
fi

# Check Rust version (optional, for desktop build)
if command -v rustc &> /dev/null; then
    RUST_ACTUAL=$(rustc --version | awk '{print $2}')
    check_version "Rust" "$RUST_ACTUAL" "$RUST_VERSION"
fi

# Check Elm version (optional, installed via npm if missing)
if command -v elm &> /dev/null; then
    ELM_ACTUAL=$(elm --version 2>/dev/null || echo "unknown")
    if [[ "$ELM_ACTUAL" != "unknown" ]]; then
        check_version "Elm" "$ELM_ACTUAL" "$ELM_VERSION"
    fi
fi

echo ""

# -----------------------------------------------------------------------------
# Locate or download PETSc/SLEPc
# -----------------------------------------------------------------------------

# Check for system PETSc/SLEPc (Debian/Ubuntu packages) - Linux only
detect_system_petsc() {
    local petsc_base="/usr/lib/petscdir"
    if [[ -d "$petsc_base" ]]; then
        local latest
        latest=$(ls -d "$petsc_base"/petsc*/x86_64-linux-gnu-real 2>/dev/null | sort -V | tail -1)
        if [[ -n "$latest" && -d "$latest" ]]; then
            echo "$latest"
            return 0
        fi
    fi
    return 1
}

detect_system_slepc() {
    local slepc_base="/usr/lib/slepcdir"
    if [[ -d "$slepc_base" ]]; then
        local latest
        latest=$(ls -d "$slepc_base"/slepc*/x86_64-linux-gnu-real 2>/dev/null | sort -V | tail -1)
        if [[ -n "$latest" && -d "$latest" ]]; then
            echo "$latest"
            return 0
        fi
    fi
    return 1
}

# Check for system packages first (Linux only)
USE_SYSTEM_PETSC=false
SYSTEM_PETSC_DIR=""
SYSTEM_SLEPC_DIR=""

if [[ "$OS" == "linux" ]]; then
    if SYSTEM_PETSC_DIR=$(detect_system_petsc) && SYSTEM_SLEPC_DIR=$(detect_system_slepc); then
        if [[ "$FORCE_REBUILD" != "true" ]]; then
            USE_SYSTEM_PETSC=true
            log_success "Found system PETSc: $SYSTEM_PETSC_DIR"
            log_success "Found system SLEPc: $SYSTEM_SLEPC_DIR"

            SYSTEM_PETSC_VERSION=$(echo "$SYSTEM_PETSC_DIR" | grep -oP 'petsc\K[0-9.]+')
            SYSTEM_SLEPC_VERSION=$(echo "$SYSTEM_SLEPC_DIR" | grep -oP 'slepc\K[0-9.]+')
            log_info "System PETSc version: $SYSTEM_PETSC_VERSION"
            log_info "System SLEPc version: $SYSTEM_SLEPC_VERSION"
        else
            log_info "System PETSc/SLEPc found but --all forces rebuild from source"
        fi
    fi
fi

# Default paths (used when building from source)
PETSC_DIR=${PETSC_DIR:-"$SCRIPT_DIR/petsc"}
SLEPC_DIR=${SLEPC_DIR:-"$SCRIPT_DIR/slepc"}

# Get platform-specific configure options
get_petsc_configure_platform() {
    case "$OS" in
        linux)  echo "$PETSC_CONFIGURE_LINUX" ;;
        macos)  echo "$PETSC_CONFIGURE_MACOS" ;;
        windows) echo "$PETSC_CONFIGURE_WINDOWS" ;;
        *)      echo "$PETSC_CONFIGURE_LINUX" ;;
    esac
}

download_and_build_petsc() {
    log_info "Downloading and building PETSc $PETSC_VERSION..."
    echo ""

    local PETSC_URL="${PETSC_URL_BASE}/petsc-$PETSC_VERSION.tar.gz"

    cd "$SCRIPT_DIR"

    if [[ ! -f "petsc-$PETSC_VERSION.tar.gz" ]]; then
        log_info "Downloading PETSc from $PETSC_URL..."
        curl -L -o "petsc-$PETSC_VERSION.tar.gz" "$PETSC_URL"
    else
        log_info "Using cached PETSc tarball"
    fi

    if [[ ! -d "petsc-$PETSC_VERSION" ]]; then
        log_info "Extracting PETSc..."
        tar xzf "petsc-$PETSC_VERSION.tar.gz"
    fi

    # Create symlink (on Windows, use directory copy if symlinks fail)
    if [[ "$OS" == "windows" ]]; then
        rm -rf petsc
        cp -r "petsc-$PETSC_VERSION" petsc
    else
        ln -sfn "petsc-$PETSC_VERSION" petsc
    fi
    PETSC_DIR="$SCRIPT_DIR/petsc"

    cd "$PETSC_DIR"

    # Get platform-specific options
    local PLATFORM_OPTS
    PLATFORM_OPTS=$(get_petsc_configure_platform)

    log_info "Configuring PETSc (optimized, with MUMPS direct solver)..."

    # Build configure arguments
    local -a CONFIGURE_ARGS=($PETSC_CONFIGURE_COMMON $PLATFORM_OPTS)
    CONFIGURE_ARGS+=(COPTFLAGS="$PETSC_COPTFLAGS" FOPTFLAGS="$PETSC_FOPTFLAGS" PETSC_ARCH="$PETSC_ARCH")

    # Windows: add MS-MPI paths (handled here due to spaces in paths)
    if [[ "$OS" == "windows" ]]; then
        local MSMPI_SDK="/c/Program Files (x86)/Microsoft SDKs/MPI"
        if [[ ! -d "$MSMPI_SDK" ]]; then
            log_error "MS-MPI SDK not found at $MSMPI_SDK"
            log_error "Install MS-MPI from https://github.com/microsoft/Microsoft-MPI/releases"
            exit 1
        fi
        CONFIGURE_ARGS+=("--with-mpi-include=$MSMPI_SDK/Include")
        CONFIGURE_ARGS+=("--with-mpi-lib=[$MSMPI_SDK/Lib/x64/msmpi.lib,$MSMPI_SDK/Lib/x64/msmpifec.lib]")
        log_info "Using MS-MPI from $MSMPI_SDK"
    fi

    $PYTHON ./configure "${CONFIGURE_ARGS[@]}"

    log_info "Building PETSc..."
    make -j PETSC_DIR="$PETSC_DIR" PETSC_ARCH="$PETSC_ARCH" all

    log_success "PETSc built successfully"
    echo ""
}

download_and_build_slepc() {
    log_info "Downloading and building SLEPc $SLEPC_VERSION..."
    echo ""

    local SLEPC_URL="${SLEPC_URL_BASE}/slepc-$SLEPC_VERSION.tar.gz"

    cd "$SCRIPT_DIR"

    if [[ ! -f "slepc-$SLEPC_VERSION.tar.gz" ]]; then
        log_info "Downloading SLEPc from $SLEPC_URL..."
        curl -L -o "slepc-$SLEPC_VERSION.tar.gz" "$SLEPC_URL"
    else
        log_info "Using cached SLEPc tarball"
    fi

    if [[ ! -d "slepc-$SLEPC_VERSION" ]]; then
        log_info "Extracting SLEPc..."
        tar xzf "slepc-$SLEPC_VERSION.tar.gz"
    fi

    # Create symlink
    if [[ "$OS" == "windows" ]]; then
        rm -rf slepc
        cp -r "slepc-$SLEPC_VERSION" slepc
    else
        ln -sfn "slepc-$SLEPC_VERSION" slepc
    fi
    SLEPC_DIR="$SCRIPT_DIR/slepc"

    cd "$SLEPC_DIR"

    # Configure and build SLEPc
    log_info "Configuring SLEPc..."
    export PETSC_DIR
    export SLEPC_DIR
    export PETSC_ARCH

    $PYTHON ./configure

    log_info "Building SLEPc..."
    make -j SLEPC_DIR="$SLEPC_DIR" PETSC_DIR="$PETSC_DIR" PETSC_ARCH="$PETSC_ARCH"

    log_success "SLEPc built successfully"
    echo ""
}

# Clone petsc-hs if needed
PETSC_HS_DIR="$SCRIPT_DIR/petsc-hs"
if [[ ! -d "$PETSC_HS_DIR" ]]; then
    log_info "Cloning petsc-hs..."
    git clone https://github.com/ccomb/petsc-hs.git "$PETSC_HS_DIR"
elif [[ "$FORCE_REBUILD" == "true" ]]; then
    log_info "Cleaning petsc-hs build artifacts..."
    rm -rf "$PETSC_HS_DIR/dist-newstyle"
fi

# Generate TypesC2HsGen.hs if it doesn't exist
TYPES_C2HS_GEN="$PETSC_HS_DIR/src/Numerical/PETSc/Internal/C2HsGen/TypesC2HsGen.hs"
if [[ ! -f "$TYPES_C2HS_GEN" ]]; then
    log_info "Generating TypesC2HsGen.hs..."
    runhaskell "$PETSC_HS_DIR/src/Numerical/PETSc/Internal/C2HsGen/GenerateC2Hs.hs" > "$TYPES_C2HS_GEN"
fi

# Check if PETSc was built with MPI and patch petsc-hs.cabal accordingly
PETSC_HS_CABAL="$PETSC_HS_DIR/petsc-hs.cabal"
PETSC_LIB_CHECK="${PETSC_DIR:-$SCRIPT_DIR/petsc}/${PETSC_ARCH:-arch-linux-c-opt}/lib"
if [[ -f "$PETSC_LIB_CHECK/libmpi.so" ]] || [[ -f "$PETSC_LIB_CHECK/libmpich.so" ]]; then
    log_info "Patching petsc-hs.cabal for MPI..."
    if grep -q "petsc, mpich, slepc" "$PETSC_HS_CABAL" 2>/dev/null; then
        sed -i 's/petsc, mpich, slepc/petsc, mpi, slepc/g' "$PETSC_HS_CABAL"
    fi
elif grep -q "mpich" "$PETSC_HS_CABAL" 2>/dev/null; then
    log_info "Patching petsc-hs.cabal to remove MPI dependency..."
    sed -i 's/petsc, mpich, slepc/petsc, slepc/g' "$PETSC_HS_CABAL"
fi

# Windows-specific patches for petsc-hs
if [[ "$OS" == "windows" ]]; then
    # Add OpenBLAS library for Windows
    if ! grep -q "openblas" "$PETSC_HS_CABAL" 2>/dev/null; then
        log_info "Adding OpenBLAS library to petsc-hs.cabal..."
        sed -i 's/\(extra-libraries:\s*petsc, slepc\)/\1, openblas/g' "$PETSC_HS_CABAL"
    fi

    # Create stub files for Windows compatibility
    CBITS_DIR="$PETSC_HS_DIR/cbits"
    mkdir -p "$CBITS_DIR"

    # HDF5 stub (we build PETSc without HDF5 on Windows)
    HDF5_STUB="$CBITS_DIR/hdf5_stub.c"
    if [[ ! -f "$HDF5_STUB" ]]; then
        log_info "Creating HDF5 stub for petsc-hs..."
        cat > "$HDF5_STUB" << 'STUB_EOF'
/* Stub for PetscViewerHDF5Open - PETSc built without HDF5 support */
typedef int PetscErrorCode;
typedef void* PetscViewer;
typedef void* MPI_Comm;
typedef int PetscFileMode;

PetscErrorCode PetscViewerHDF5Open(MPI_Comm comm, const char name[], PetscFileMode type, PetscViewer *viewer) {
    (void)comm; (void)name; (void)type; (void)viewer;
    return -1; /* PETSC_ERR_SUP - not supported */
}
STUB_EOF
    fi

    # MinGW runtime stub
    MINGW_STUB="$CBITS_DIR/mingw_stub.c"
    if [[ ! -f "$MINGW_STUB" ]]; then
        log_info "Creating MinGW runtime stub for petsc-hs..."
        cat > "$MINGW_STUB" << 'STUB_EOF'
/* Stubs for MinGW runtime symbols not found by ld.lld on Windows */
#ifdef _WIN32

#include <windows.h>
#include <stdint.h>
#include <time.h>
#include <sys/stat.h>
#include <setjmp.h>

typedef int (*setjmp_func_t)(jmp_buf);
extern int __cdecl _setjmp(jmp_buf _Buf, void *_Ctx);
void* __imp__setjmp = (void*)_setjmp;

typedef struct {
    unsigned int __cw;
    unsigned int __sw;
    unsigned int __tag;
    unsigned int __ipoff;
    unsigned int __cssel;
    unsigned int __dataoff;
    unsigned int __datasel;
    unsigned int __mxcsr;
} stub_fenv_t;

const stub_fenv_t __mingw_fe_dfl_env = { 0x37f, 0, 0, 0, 0, 0, 0, 0x1f80 };

int stat64i32(const char *path, struct _stat64 *buf) {
    return _stat64(path, buf);
}

struct timespec64 {
    int64_t tv_sec;
    int64_t tv_nsec;
};

int nanosleep64(const struct timespec64 *req, struct timespec64 *rem) {
    if (req == NULL) return -1;
    DWORD ms = (DWORD)(req->tv_sec * 1000 + req->tv_nsec / 1000000);
    if (ms > 0) Sleep(ms);
    if (rem) { rem->tv_sec = 0; rem->tv_nsec = 0; }
    return 0;
}

#endif /* _WIN32 */
STUB_EOF
    fi

    # Add c-sources to petsc-hs.cabal if not already present
    if ! grep -q "hdf5_stub.c" "$PETSC_HS_CABAL" 2>/dev/null; then
        log_info "Adding stub files to petsc-hs.cabal..."
        sed -i 's/\(extra-libraries:\s*petsc\)/c-sources: cbits\/hdf5_stub.c\n             cbits\/mingw_stub.c\n  \1/g' "$PETSC_HS_CABAL"
    fi
fi

# Use system packages or build from source
if [[ "$USE_SYSTEM_PETSC" == "true" ]]; then
    # Use system packages
    PETSC_DIR="$SYSTEM_PETSC_DIR"
    SLEPC_DIR="$SYSTEM_SLEPC_DIR"
    PETSC_ARCH=""  # System packages don't use PETSC_ARCH
    USE_SYSTEM_LIBS=true

    # Debian uses libpetsc_real.so and libslepc_real.so
    PETSC_LIB_NAME="petsc_real"
    SLEPC_LIB_NAME="slepc_real"

    # Patch petsc-hs.cabal to use system library names
    if ! grep -q "petsc_real" "$PETSC_HS_CABAL" 2>/dev/null; then
        log_info "Patching petsc-hs.cabal for system library names..."
        sed -i 's/petsc, slepc/petsc_real, slepc_real/g' "$PETSC_HS_CABAL"
    fi

    log_success "Using system PETSc: $PETSC_DIR"
    log_success "Using system SLEPc: $SLEPC_DIR"
else
    USE_SYSTEM_LIBS=false
    PETSC_LIB_NAME="petsc"
    SLEPC_LIB_NAME="slepc"

    # Download/build PETSc if needed or forced
    if [[ "$FORCE_REBUILD" == "true" ]] || [[ ! -d "$PETSC_DIR/$PETSC_ARCH" ]]; then
        if [[ "$FORCE_REBUILD" == "true" && -d "$PETSC_DIR" ]]; then
            log_info "Removing existing PETSc for rebuild..."
            rm -rf "$PETSC_DIR" petsc-*.tar.gz petsc-[0-9]*
        fi
        download_and_build_petsc
    fi

    # Download/build SLEPc if needed or forced
    if [[ "$FORCE_REBUILD" == "true" ]] || [[ ! -d "$SLEPC_DIR/$PETSC_ARCH" ]]; then
        if [[ "$FORCE_REBUILD" == "true" && -d "$SLEPC_DIR" ]]; then
            log_info "Removing existing SLEPc for rebuild..."
            rm -rf "$SLEPC_DIR" slepc-*.tar.gz slepc-[0-9]*
        fi
        download_and_build_slepc
    fi

    log_success "Using PETSc: $PETSC_DIR/$PETSC_ARCH"
    log_success "Using SLEPc: $SLEPC_DIR/$PETSC_ARCH"
fi
echo ""

# -----------------------------------------------------------------------------
# Set up environment
# -----------------------------------------------------------------------------

if [[ "$USE_SYSTEM_LIBS" == "true" ]]; then
    PETSC_LIB_DIR="/usr/lib/x86_64-linux-gnu"
    SLEPC_LIB_DIR="/usr/lib/x86_64-linux-gnu"
    PETSC_INCLUDE_DIR="$PETSC_DIR/include"
    SLEPC_INCLUDE_DIR="$SLEPC_DIR/include"
else
    PETSC_LIB_DIR="$PETSC_DIR/$PETSC_ARCH/lib"
    SLEPC_LIB_DIR="$SLEPC_DIR/$PETSC_ARCH/lib"
    PETSC_INCLUDE_DIR="$PETSC_DIR/include"
    PETSC_ARCH_INCLUDE_DIR="$PETSC_DIR/$PETSC_ARCH/include"
    SLEPC_INCLUDE_DIR="$SLEPC_DIR/include"
    SLEPC_ARCH_INCLUDE_DIR="$SLEPC_DIR/$PETSC_ARCH/include"
fi

export LD_LIBRARY_PATH="$PETSC_LIB_DIR:$SLEPC_LIB_DIR${LD_LIBRARY_PATH:+:$LD_LIBRARY_PATH}"

if [[ "$USE_SYSTEM_LIBS" == "true" ]]; then
    export C_INCLUDE_PATH="$PETSC_INCLUDE_DIR:$SLEPC_INCLUDE_DIR${C_INCLUDE_PATH:+:$C_INCLUDE_PATH}"
    export CPLUS_INCLUDE_PATH="$PETSC_INCLUDE_DIR:$SLEPC_INCLUDE_DIR${CPLUS_INCLUDE_PATH:+:$CPLUS_INCLUDE_PATH}"
else
    export C_INCLUDE_PATH="$PETSC_INCLUDE_DIR:$PETSC_ARCH_INCLUDE_DIR:$SLEPC_INCLUDE_DIR:$SLEPC_ARCH_INCLUDE_DIR${C_INCLUDE_PATH:+:$C_INCLUDE_PATH}"
    export CPLUS_INCLUDE_PATH="$PETSC_INCLUDE_DIR:$PETSC_ARCH_INCLUDE_DIR:$SLEPC_INCLUDE_DIR:$SLEPC_ARCH_INCLUDE_DIR${CPLUS_INCLUDE_PATH:+:$CPLUS_INCLUDE_PATH}"
fi

export PETSC_DIR
export SLEPC_DIR
export PETSC_ARCH

# On Windows, add MSYS2 bin dir to PATH for DLL discovery
if [[ "$OS" == "windows" ]]; then
    # Use Windows path format for MSYS2 bin
    MSYS2_BIN_WIN="/ucrt64/bin"
    export PATH="$PETSC_LIB_DIR:$SLEPC_LIB_DIR:$MSYS2_BIN_WIN:$PATH"
fi

# -----------------------------------------------------------------------------
# Clean if requested
# -----------------------------------------------------------------------------

if [[ "$CLEAN_BUILD" == "true" ]]; then
    log_info "Cleaning build artifacts..."
    cd "$SCRIPT_DIR"
    rm -rf dist-newstyle cabal.project.local
    if [[ -d "$SCRIPT_DIR/petsc-hs" ]]; then
        cd "$SCRIPT_DIR/petsc-hs"
        rm -rf dist-newstyle cabal.project.local
    fi
    log_success "Clean complete"
    echo ""
fi

# -----------------------------------------------------------------------------
# Build fplca (petsc-hs is built automatically as a dependency)
# -----------------------------------------------------------------------------

log_info "Building fplca..."
cd "$SCRIPT_DIR"

# Write cabal.project.local with library paths
if [[ "$USE_SYSTEM_LIBS" == "true" ]]; then
    cat > cabal.project.local << EOF
extra-lib-dirs: $PETSC_LIB_DIR
              , $SLEPC_LIB_DIR
extra-include-dirs: $PETSC_INCLUDE_DIR
                  , $SLEPC_INCLUDE_DIR
EOF
elif [[ "$OS" == "windows" ]]; then
    # Windows needs additional library paths and linker options
    MSYS2_LIB_DIR="/ucrt64/lib"
    GCC_LIB_DIR=$(find /ucrt64/lib/gcc/x86_64-w64-mingw32 -maxdepth 1 -type d 2>/dev/null | sort -V | tail -1)

    cat > cabal.project.local << EOF
extra-lib-dirs: $PETSC_LIB_DIR
              , $SLEPC_LIB_DIR
              , $MSYS2_LIB_DIR
extra-include-dirs: $PETSC_INCLUDE_DIR
                  , $PETSC_ARCH_INCLUDE_DIR
                  , $SLEPC_INCLUDE_DIR
                  , $SLEPC_ARCH_INCLUDE_DIR

-- Link MinGW runtime libs and OpenBLAS needed by PETSc (built with UCRT64)
package fplca
  ghc-options: -optl-L$GCC_LIB_DIR -optl-lgcc -optl-L$MSYS2_LIB_DIR -optl-lopenblas -optl-lquadmath -optl-lmingwex -optl-lpthread -optl-lmsvcrt
EOF

    # Copy OpenBLAS DLLs for GHC to find
    log_info "Copying OpenBLAS DLLs for GHC..."
    for dll in $WINDOWS_OPENBLAS_DLLS; do
        src="/ucrt64/bin/$dll"
        if [[ -f "$src" ]]; then
            cp "$src" "$SCRIPT_DIR/"
        fi
    done
else
    # Linux/macOS custom build
    cat > cabal.project.local << EOF
extra-lib-dirs: $PETSC_LIB_DIR
              , $SLEPC_LIB_DIR
extra-include-dirs: $PETSC_INCLUDE_DIR
                  , $PETSC_ARCH_INCLUDE_DIR
                  , $SLEPC_INCLUDE_DIR
                  , $SLEPC_ARCH_INCLUDE_DIR
EOF
fi

if [[ "$USE_SYSTEM_LIBS" == "true" ]]; then
    log_info "Using system libraries: $PETSC_LIB_NAME, $SLEPC_LIB_NAME"
fi

cabal build -O2

log_success "fplca built successfully"
echo ""

# -----------------------------------------------------------------------------
# Build frontend
# -----------------------------------------------------------------------------

if [[ -d "$SCRIPT_DIR/web" ]]; then
    log_info "Building frontend..."
    cd "$SCRIPT_DIR/web"
    if [[ ! -d "node_modules" ]]; then
        npm install --silent
    fi
    ./build.sh
    log_success "Frontend built successfully"
    echo ""
fi

# -----------------------------------------------------------------------------
# Run tests
# -----------------------------------------------------------------------------

if [[ "$RUN_TESTS" == "true" ]]; then
    log_info "Running tests..."
    cd "$SCRIPT_DIR"
    cabal test --test-show-details=streaming
    log_success "Tests passed"
    echo ""
fi

# -----------------------------------------------------------------------------
# Build desktop application (if requested)
# -----------------------------------------------------------------------------

if [[ "$BUILD_DESKTOP" == "true" ]]; then
    log_info "Building desktop application..."
    cd "$SCRIPT_DIR/desktop"
    ./build-desktop.sh
    log_success "Desktop application built"
    echo ""
fi

# -----------------------------------------------------------------------------
# Summary
# -----------------------------------------------------------------------------

echo ""
echo "============================================================================="
log_success "Build completed successfully!"
echo "============================================================================="
echo ""

if [[ "$OS" == "windows" ]]; then
    echo "To run fplca, first ensure the DLLs are in PATH:"
    echo ""
    echo "  export PATH=\"$PETSC_LIB_DIR:$SLEPC_LIB_DIR:/ucrt64/bin:\$PATH\""
else
    echo "To run fplca, first set up the library path:"
    echo ""
    echo "  export LD_LIBRARY_PATH=\"$PETSC_DIR/$PETSC_ARCH/lib:$SLEPC_DIR/$PETSC_ARCH/lib:\$LD_LIBRARY_PATH\""
fi
echo ""
echo "Then run:"
echo ""
echo "  cabal run fplca -- --help"
echo ""

# Find the built executable
if [[ "$OS" == "windows" ]]; then
    FPLCA_BIN=$(find "$SCRIPT_DIR/dist-newstyle" -name "fplca.exe" -type f 2>/dev/null | head -1)
else
    FPLCA_BIN=$(find "$SCRIPT_DIR/dist-newstyle" -name "fplca" -type f -executable 2>/dev/null | head -1)
fi
if [[ -n "$FPLCA_BIN" ]]; then
    echo "Executable: $FPLCA_BIN"
    echo ""
fi

# Show desktop build instructions if not already built
if [[ "$BUILD_DESKTOP" != "true" ]]; then
    echo "To build the desktop application:"
    echo ""
    echo "  ./build.sh --desktop"
    echo ""
    echo "Or manually:"
    echo "  cd desktop && ./build-desktop.sh"
    echo ""
fi
